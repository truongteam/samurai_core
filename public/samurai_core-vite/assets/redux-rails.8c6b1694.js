import{a as Se,c as he}from"./_commonjsHelpers.042e6b4d.js";import{r as Te}from"./redux.3c9f6592.js";var re={},Oe={get exports(){return re},set exports(W){re=W}};const ve=Se(Te);(function(W,_e){(function(V,_){W.exports=_(ve)})(typeof self<"u"?self:he,function(V){return function(_){var y={};function f(l){if(y[l])return y[l].exports;var b=y[l]={i:l,l:!1,exports:{}};return _[l].call(b.exports,b,b.exports,f),b.l=!0,b.exports}return f.m=_,f.c=y,f.d=function(l,b,A){f.o(l,b)||Object.defineProperty(l,b,{enumerable:!0,get:A})},f.r=function(l){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(l,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(l,"__esModule",{value:!0})},f.t=function(l,b){if(1&b&&(l=f(l)),8&b||4&b&&typeof l=="object"&&l&&l.__esModule)return l;var A=Object.create(null);if(f.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:l}),2&b&&typeof l!="string")for(var R in l)f.d(A,R,function(C){return l[C]}.bind(null,R));return A},f.n=function(l){var b=l&&l.__esModule?function(){return l.default}:function(){return l};return f.d(b,"a",b),b},f.o=function(l,b){return Object.prototype.hasOwnProperty.call(l,b)},f.p="",f(f.s=1)}([function(_,y){_.exports=V},function(_,y,f){f.r(y),f.d(y,"apiReducer",function(){return me}),f.d(y,"combineConfigs",function(){return fe}),f.d(y,"middleWare",function(){return ce}),f.d(y,"railsActions",function(){return pe});let l=0;const b=({resourceConfig:r,config:t,defaultConfig:o={}})=>j(r.optimisticUpdateEnabled)?r.optimisticUpdateEnabled:j(t.resources.optimisticUpdateEnabled)?t.resources.optimisticUpdateEnabled:j(t.optimisticUpdateEnabled)?t.optimisticUpdateEnabled:!j(o.optimisticUpdateEnabled)||o.optimisticUpdateEnabled,A=({controller:r})=>r[r.length-1]==="s"?"collection":"member",R=({config:r,resource:t})=>{const o=r.resources[t].controller;return A({controller:o})==="collection"?"models":"attributes"},C=({config:r,resource:t})=>r.resources[t].idAttribute||"id",j=r=>typeof r=="boolean",$=({config:r,store:t})=>typeof r=="function"?r(t):r;let Y={};const L={SHOW:"GET",INDEX:"GET",CREATE:"POST",UPDATE:"PUT",DESTROY:"DELETE"},Z=(r,t)=>`${r}=${encodeURIComponent(t)}`,ae=(r,t)=>Array.isArray(t)?((o,a)=>a.map(e=>Z(o+"[]",e)))(r,t):Z(r,t),oe=({baseUrl:r,controller:t,railsAction:o,data:a,queryParams:e={}})=>{const i=A({controller:t}),n=(s=>s.includes("/:id/"))(t),c=()=>n||i==="collection"&&o!=="INDEX"&&o!=="CREATE"?"/"+a.id:"",p=((s={},d)=>{const u=Object.keys(s).filter(m=>s[m]!==void 0||s[m]!==null);return u.length===0||L[d]!=="GET"?"":"?"+u.map(m=>ae(m,s[m])).join("&")})(e,o);let g;return g=n?`${r}${t}`.replace("/:id",c()):`${r}${t}${c()}`,`${g}${p}`},F=({store:r,resource:t,railsAction:o,error:a,id:e,cId:i,optimisticUpdateEnabled:n,reject:c})=>{const p={type:`${t}.${o}_ERROR`,error:a,id:e,cId:i},g=o==="CREATE";r.dispatch(p),["CREATE","UPDATE"].includes(o)&&n&&r.dispatch({type:t+".UNSET_OPTIMISTIC_DATA",id:e,cId:i,destroy:g}),c(p)},Q=({store:r,resource:t,config:o,data:a={},railsAction:e,controllerOverride:i,fetchParamsOverride:n,queryParamsOverride:c,resolve:p,reject:g})=>{const s=o.resources[t],d=s.baseUrl||o.baseUrl,u=i||s.controller,m=C({config:o,resource:t}),h=n||s.fetchParams||o.fetchParams,O=c||s.queryParams||o.queryParams,I=(({railsAction:T,resource:D,config:N,data:G,fetchParams:k={}})=>{const X=L[T],K=new Headers(k.headers||{});let H=Object.assign({},k,{method:X,headers:K});return typeof G=="object"&&X!=="GET"&&(H.body=JSON.stringify(G)),H})({railsAction:e,resource:t,data:a,config:o,fetchParams:h}),P=oe({baseUrl:d,controller:u,railsAction:e,data:a,fetchParams:h,queryParams:O}),x=b({resourceConfig:s,config:o});let v;e==="CREATE"&&(v=++l,r.dispatch({type:t+".ASSIGN_CID",cId:v}),r.dispatch({type:t+".SET_LOADING",cId:v})),["CREATE","UPDATE"].includes(e)&&x&&r.dispatch({type:t+".SET_OPTIMISTIC_DATA",id:a.id,cId:v,data:a}),fetch(P,I).then(T=>{T.json().then(D=>{const N=D&&D[m]||a.id;if(!T.ok)return F({store:r,resource:t,railsAction:e,id:N,cId:v,optimisticUpdateEnabled:x,reject:g,error:D.error||{message:T.statusText}});(({store:G,resource:k,railsAction:X,id:K,cId:H,json:be,config:Ee,controller:ge,resolve:Ie})=>{const De=`${k}.${X}_SUCCESS`,{response:ye,metaData:Ae}=se({json:be,resource:k,config:Ee,resourceType:A({controller:ge})}),te={cId:H,id:K,metaData:Ae,response:ye,type:De};G.dispatch(te),Ie(te)})({store:r,resource:t,railsAction:e,id:N,cId:v,json:D,config:o,controller:u,optimisticUpdateEnabled:x,resolve:p})}).catch(D=>{const N=D&&D.toString&&D.toString();F({store:r,resource:t,railsAction:e,error:N,id:a.id,cId:v,optimisticUpdateEnabled:x,reject:g})})}).catch(T=>{F({store:r,resource:t,railsAction:e,error:T,id:a.id,cId:v,optimisticUpdateEnabled:x,reject:g})}).then(()=>(({resource:T})=>{const D=ee({resource:T});D.shift(),D.length>0&&Q(D[0])})({resource:t}))},ee=({resource:r})=>(Y[r]||(Y[r]={queue:[]}),Y[r].queue),se=({json:r,resource:t,config:o,resourceType:a})=>{const e=o.resources[t].parse,i=o.resources[t].setMetadata;let n,c={};switch(typeof e){case"object":{const p=e&&e[a];if(!p){n=r;break}n=p(r);break}case"function":n=e(r);break;default:n=r}switch(typeof i){case"object":{const p=i&&i[a];if(!p)break;c=p(r);break}case"function":c=i(r);break;default:c={}}return{response:n,metaData:c}},ie=({action:r,config:t,fetchData:o,next:a,resource:e,resourceConfig:i})=>{const n=new Promise((c,p)=>{const g={resolve:c,reject:p,...o};(t.disableFetchQueueing||i.disableFetchQueueing)&&Q(g),((s,d)=>{const u=ee({resource:s});u.push(d),u.length<=1&&Q(d)})(e,g)});return a(r),n};var ce=r=>t=>o=>a=>{const e=$({config:r,store:t.getState()}),[i,n]=a.type.split("."),{data:c,controller:p,fetchParams:g}=a,{queryParams:s}=c||{},d={store:t,resource:i,config:e,data:c,railsAction:n,controllerOverride:p,fetchParamsOverride:g,queryParamsOverride:s},u=e.resources[i];return u&&L[n]?ie({action:a,config:e,fetchData:d,next:o,resource:i,resourceConfig:u}):o(a)},de=f(0);const B={loading:!1,loadingError:void 0,__prevData:void 0},q=({id:r,cId:t,state:o})=>{let a,e;return(o.models&&o.models.slice(0)||[]).find(i=>(a=i.id!==void 0,e=t!==void 0,a&&i.id===r||e&&i.cId===t))},E=({id:r,cId:t,metaData:o,attributes:a={}})=>{let e={id:r,cId:t,attributes:{...a}};return Object.keys(e).forEach(i=>e[i]===void 0?delete e[i]:""),{...B,...o,...e}},S=({metaData:r,models:t=[]})=>({...B,...r,models:t}),J=({state:r,model:t})=>[...r.models||[],t],z=({id:r,cId:t,state:o,updatedModel:a})=>{let e,i;return(o.models&&o.models.slice(0)||[]).map(n=>(e=n.id!==void 0,i=t!==void 0,e&&n.id===r||i&&n.cId===t?a:n))},U=({id:r,data:t,metaData:o,state:a,cId:e,replaceAttributes:i=!0,replaceMeta:n=!0})=>{const c=q({id:r,cId:e,state:a});let p;return c?(p=i?t:{...c.attributes,...t},!e&&c.cId&&(e=c.cId),z({id:r,cId:e,state:a,updatedModel:E({id:r,cId:e,metaData:o,attributes:p})})):J({state:a,model:E({id:r,cId:e,metaData:o,attributes:t})})},ne=({id:r,state:t})=>t.models.filter(o=>o.id!==r),ue=({cId:r,state:t})=>t.models.filter(o=>o.cId!==r),M=({id:r,cId:t,state:o,queryParams:a})=>{const e=q({id:r,cId:t,state:o});return e?z({id:r,cId:t,state:o,updatedModel:E({id:r,cId:t,metaData:{loading:!0,queryParams:a},attributes:e.attributes})}):J({state:o,model:E({id:r,cId:t,metaData:{loading:!0,queryParams:a}})})},w=({id:r,cId:t,state:o,error:a})=>{const e=q({id:r,cId:t,state:o});return e||r?e?z({id:r,state:o,cId:t,updatedModel:E({...e,metaData:{loadingError:a,__prevData:e.__prevData}})}):J({state:o,model:E({id:r,metaData:{loadingError:a}})}):o.models.slice(0)},le=({config:r,resource:t})=>{const o=R({config:r,resource:t}),a=o==="attributes",e=r.resources[t]||{},i=C({config:r,resource:t});let n;return a?(n=e[o]?e[i]||e.attributes[i]:void 0,E({id:n,idAttribute:i,attributes:e.attributes})):S({models:(e.models||[]).map(c=>E({idAttribute:i,id:c[i],attributes:c}))})};var me=r=>{const t=$({config:r}),o={};return Object.keys(t.resources).forEach(a=>{o[a]=(e=le({config:t,resource:a}),i={})=>{const n=t.resources[a]||{},c=R({config:t,resource:a})==="attributes",p=C({config:t,resource:a}),{queryParams:g}=i.data||{};switch(i.type){case a+".INDEX":{const{paginated:s}=n;return{...e,...S({metaData:{loading:!0,queryParams:g},models:s?e.models:[]})}}case a+".INDEX_SUCCESS":{let{response:s,metaData:d}=i;const u=i.response[a]||i.response[a.toLowerCase()];if(!Array.isArray(i.response)){if(!u||!Array.isArray(u))return console.error("Response to INDEX actions must be of type array OR contain a top-level key matching the resource name with an array as the value. You can use the parse method(s) set in your config for this resource to transform returned data if needed."),{...e,...S({metaData:{loading:!1,loadingError:"Bad data received from server. INDEX calls expect an array."}})};s=u}if(n.paginated){const m=s.reduce((I,P)=>({...I,[P.id]:P}),{}),h=e.models.map(I=>I.attributes),O={};s=[...h.map(I=>m[I.id]?(O[I.id]=!0,m[I.id]):I),...s.filter(I=>!O[I.id])]}return{...e,...S({models:s.map(m=>E({id:m[p],attributes:m})),metaData:d})}}case a+".INDEX_ERROR":{const{error:s}=i;return{...e,...S({metaData:{loading:!1,loadingError:s}})}}case a+".SHOW":{const s=i.data||{},{id:d}=s;return c?E({metaData:{loading:!0,queryParams:g},attributes:e.attributes}):{...e,models:M({id:d,state:e,queryParams:g})}}case a+".SHOW_SUCCESS":{const{id:s,response:d,metaData:u}=i,m=d;return c?E({id:s,metaData:u,attributes:{...e.attributes,...m}}):{...e,...S({models:U({id:s,data:m,state:e,metaData:{loading:!1,...u}})})}}case a+".SHOW_ERROR":{const{id:s,error:d}=i;return c?E({id:s,attributes:{...e.attributes},metaData:{loadingError:d}}):{...e,models:w({state:e,id:s,error:d})}}case a+".ASSIGN_CID":{const{cId:s}=i;return c?E({cId:s}):S({models:U({cId:s,state:e})})}case a+".CREATE_SUCCESS":{const{cId:s,id:d,response:u,metaData:m}=i,h=u;return c?E({id:d,cId:s,attributes:{...e.attributes,...h},metaData:m}):S({models:U({data:h,state:e,id:d,cId:s,metaData:m})})}case a+".CREATE_ERROR":{const{id:s,cId:d,error:u}=i;return c?E({id:s,cId:d,metaData:{loadingError:u}}):{...e,models:w({state:e,id:s,cId:d,error:u})}}case a+".UPDATE":{const s=i.data||{},{id:d}=s,u=e.__prevData;return c?E({id:d,metaData:{loading:!0,__prevData:u},attributes:e.attributes}):{...e,models:M({id:d,state:e})}}case a+".UPDATE_SUCCESS":{const{id:s,metaData:d,response:u}=i,m=u;return c?E({id:s,attributes:{...e.attributes,...m},metaData:d}):{...e,models:U({id:s,data:m,metaData:d,state:e,replaceAttributes:!1})}}case a+".UPDATE_ERROR":{const{id:s,error:d}=i;return c?E({id:s,attributes:e.attributes,metaData:{loadingError:d}}):{...e,models:w({state:e,id:s,error:d})}}case a+".DESTROY":{const s=(i.data||{}).id||e.id;return c?E({id:s,attributes:e.attributes,metaData:{loading:!0}}):{...e,models:M({idAttribute:p,id:s,state:e})}}case a+".DESTROY_SUCCESS":{const{id:s}=i;return c?null:{...e,models:ne({idAttribute:p,id:s,state:e})}}case a+".DESTROY_ERROR":{const{id:s,error:d}=i;return c?{...e,loading:!1,loadingError:d}:{...e,models:w({state:e,id:s,idAttribute:p,error:d})}}case a+".SET_LOADING":{const{id:s,cId:d}=i;return c?{...e,loading:!0,loadingError:void 0}:{...e,models:M({idAttribute:p,id:s,cId:d,state:e})}}case a+".SET_OPTIMISTIC_DATA":{const{id:s,cId:d,data:u}=i,m=c?e:q({id:s,cId:d,state:e}),h={...m.attributes};let O,I={};return Object.keys(B).forEach(P=>{I[P]=m[P]}),O={...I,__prevData:h},c?E({id:s,cId:d,attributes:{...m.attributes,...u},metaData:O}):S({models:U({data:u,state:e,id:s,cId:d,metaData:O})})}case a+".UNSET_OPTIMISTIC_DATA":{const{id:s,cId:d,destroy:u}=i,m=c?e:q({id:s,cId:d,state:e});return u&&c?null:u?{...e,models:ue({cId:d,state:e})}:c?E({id:s,cId:d,attributes:m.__prevData}):S({models:U({data:m.__prevData,state:e,id:s,cId:d})})}default:{const s=t.resources[a];return s&&s.reducer?s.reducer(e,i):e}}}}),Object(de.combineReducers)(o)},pe={index:({resource:r,controller:t,queryParams:o})=>({type:r+".INDEX",data:{queryParams:o},controller:t}),show:({id:r,resource:t,controller:o,queryParams:a})=>({type:t+".SHOW",data:{id:r,queryParams:a},controller:o}),update:({id:r,attributes:t,resource:o,controller:a})=>({type:o+".UPDATE",data:{id:r,...t},controller:a}),create:({resource:r,attributes:t,controller:o})=>({type:r+".CREATE",data:t,controller:o}),destroy:({id:r,resource:t,controller:o})=>({type:t+".DESTROY",data:{id:r},controller:o})},fe=(...r)=>{const t=$({config:r[0]})||{};let o=Object.assign({},t,{resources:Object.assign({},t.resources)});return r.map(a=>{const e=$({config:a});if(!e.resources)return;const i={};return Object.keys(e.resources||{}).forEach(n=>{const c=e.resources[n];n==="baseUrl"&&typeof c=="string"||n==="optimisticUpdateEnabled"&&j(c)||(i[n]=Object.assign({},c,{baseUrl:c.baseUrl||e.resources.baseUrl||t.baseUrl,optimisticUpdateEnabled:b({resourceConfig:c,config:e,defaultConfig:t})}))}),i}).filter(a=>a!==void 0).forEach(a=>{Object.keys(a).forEach(e=>{let i=a[e];o.resources[e]=Object.assign({},i)})}),o}}])})})(Oe);export{re as r};
//# sourceMappingURL=redux-rails.8c6b1694.js.map
